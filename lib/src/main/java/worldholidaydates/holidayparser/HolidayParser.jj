options
{
  JDK_VERSION = "1.8";

  static = false;

  LOOKAHEAD= 6;
  IGNORE_CASE = true;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 2;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(HolidayParser)

package worldholidaydates.holidayparser;

import java.util.ArrayList;
import java.util.Locale;
import java.util.List;

import worldholidaydates.Utils;
import worldholidaydates.holidayparser.EastAsianDate.CalendarType;
import worldholidaydates.holidayparser.HijraDate.HijraMonth;
import worldholidaydates.holidayparser.HebrewDate.HebrewMonth;
import worldholidaydates.holidayparser.GregorianDate.GregorianMonth;

public class HolidayParser {
    static int DEFAULT_YEAR = 2021;
    Rule rule;

    public static void main (String[] args) throws ParseException, TokenMgrError {
        // nothing here
    }

    public Rule parse() throws ParseException {
        rule = new Rule();
        return start();
    }

}

PARSER_END(HolidayParser)

SKIP : { " " }
TOKEN :
{
    < DASH : "-" >
|   < PLUS : "+" >
|   < COLON : ":" >
|   < COMMA : "," >
}

TOKEN : { < YEAR :  (< DIGIT >){4} > }

TOKEN :
{
    < GREGORIAN_MONTH :
      "January"
    | "Febuary"
    | "March"
    | "April"
    | "May"
    | "June"
    | "July"
    | "August"
    | "September"
    | "October"
    | "November"
    | "December" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < HIJRA_MONTH:
        "Muharram"
    |   "Safar"
    |   "Rabi al-awwal"
    |   "Rabi al-thani"
    |   "Jumada al-awwal"
    |   "Jumada al-thani"
    |   "Rajab"
    |   "Shaban"
    |   "Ramadan"
    |   "Shawwal"
    |   "Dhu al-Qidah"
    |   "Dhu al-Hijjah" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < HEBREW_MONTH:
        "Nisan"
    |   "Iyyar"
    |   "Sivan"
    |   "Tamuz"
    |   "Av"
    |   "Elul"
    |   "Tishrei"
    |   "Cheshvan"
    |   "Kislev"
    |   "Tevet"
    |   "Shvat"
    |   "Adar">
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
}

TOKEN :
{
    < WEEKDAY : 
        "Monday"
    |   "Tuesday"
    |   "Wednesday"
    |   "Thursday"
    |   "Friday"
    |   "Saturday"
    |   "Sunday" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < AFTER : "after" >
|   < BEFORE : "before" >
|   < IN : "in" >
|   < NEXT : "next" >
|   < PREVIOUS : "previous" >
|   < SUBSTITUTES : "substitutes" >
|   < AND : "and" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < DAYS_PH :
        "days"
    |   "d" >
}

TOKEN :
{
    < ISO_PERIOD : "P" >
|   < ISO_DAY : "D" >
|   < ISO_TIME : "T" >
|   < ISO_HOUR : "H" >
|   < ISO_MINUTE : "M" >
    {
        matchedToken.image = image.toString().toUpperCase(Locale.US);
    }
}

TOKEN :
{
    < EASTER :
        "Easter"
    |   "Orthodox" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
}

TOKEN : 
{
    < EASTASIAN_CALENDER :
        "Chinese"
    |   "Korean"
    |   "Vietnamese" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < SOLARTERM : "solarterm" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < BENGALI_REVISED :
        "bengali-revised" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN:
{
    < SOLSTICE :
        "solstice" >
|
    < EQUINOX:
        "equinox" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < NUMBER : (< DIGIT >)+ >
|   < DIGIT : [ "0"-"9" ] >
}

TOKEN :
{
    < COUNT_SUFFIX:
        "st"
    |   "nd"
    |   "rd"
    |   "th" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < EVEN : "even years" >
|   < ODD : "odd years" >
|   < LEAP : "leap years" >
|   < NON_LEAP : "non-leap years" >
}

TOKEN :
{
    < TIMEZONE :
        (["A"-"Z"]){3}
    |   (< PLUS > | < DASH >) <NUMBER> ":" <NUMBER>
    |    (["a"-"z","A"-"Z"])+ "/" (["a"-"z","A"-"Z"])+ >
}

TOKEN :
{
    < IF : "if" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
|   < THEN : "then" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

Rule start():
{
    Date d = null;
    int startTime = 0;
    int range = 0;
    List < List < Integer > > ifWeekdays = new ArrayList < List < Integer > > ();
    List < Integer > altTime = new ArrayList < Integer > ();
    Token substitute = null;
}
{
    ( substitute = < SUBSTITUTES > )?
    (
        LOOKAHEAD( offset() )
        offset()
    )?
    (
        LOOKAHEAD( gregorianDate() )
        (
            d = gregorianDate()
        )?
    |
        LOOKAHEAD( startOfMonth() )
        (
            d = startOfMonth()
        )?
    |
        LOOKAHEAD( easterOrthodox() )
        (
            d = easterOrthodox()
        )?
    |
        LOOKAHEAD( hijra() )
        (
            d = hijra()
        )?
    |
        LOOKAHEAD( hebrew() )
        (
            d = hebrew()
        )?
    |
        LOOKAHEAD( eastAsian() )
        (
            d = eastAsian()
        )?
    |
        LOOKAHEAD( bengaliRevised() )
        (
            d = bengaliRevised()
        )?
    |
        LOOKAHEAD( nthWeekday() )
        (
            d = nthWeekday()
        )?
    )
    (
        LOOKAHEAD( < NUMBER > < COLON > < NUMBER > )
        (
            startTime = startTime()
            {
                d.setStartTime(startTime);
            }
        )
    )?
    (
        LOOKAHEAD( < ISO_PERIOD > )
        differentRange()
    )?
    (
        LOOKAHEAD( ifRule() )
        ifRule()
    )?
    (
        LOOKAHEAD( specialYear() )
        specialYear()
    )?
    < EOF >
    {   
        if (substitute != null) {
            rule.setSubstituteCheck(true);
        }
        if (d != null) {
            rule.setRawDate(d);
        }
        // TODO: refactor this
        if (rule.getIfWeekdays() == null) {
            rule.setIfWeekdays(ifWeekdays);
        }
        if (rule.getAlternateTime() == null) {
            rule.setAlternateTime(altTime);
        }
        return rule;
    }
}

void offset() throws NumberFormatException:
{
    Token t;
    boolean isAfter = true;
    int offset = 0;
}
{
    (
        (
            LOOKAHEAD( weekdayOffset() )
                weekdayOffset()
            |
            LOOKAHEAD( dayOffset() )
                dayOffset()
        )
        (
            < BEFORE >
            {
                rule.setOffsetDirection(false);
            }
            |
            < AFTER >
            {
                rule.setOffsetDirection(true);
            }
        )
    )
}

void dayOffset() throws NumberFormatException:
{
    Token t;
    int offset = 0;
}
{
    (
        t = < NUMBER >
        {
            offset = Integer.parseInt(t.image);
            rule.setOffset(offset);
        }
        (< DAYS_PH >)?
    )
}

void weekdayOffset() throws NumberFormatException:
{
    Token t;
    int offsetWeekDayNth = 1;
    int offsetWeekDay = 0;
}
{
    (
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER })
            t = < NUMBER >
            {
                offsetWeekDayNth = Integer.parseInt(t.image);
                rule.setOffsetWeekDayNth(offsetWeekDayNth);
            }
            < COUNT_SUFFIX >
        )?
        t = < WEEKDAY >
        {
            offsetWeekDay = Date.weekdayToValue(t.image);
        }
    )
    {
        rule.setOffsetWeekDayNth(offsetWeekDayNth);
        rule.setOffsetWeekDay(offsetWeekDay);
    }
}

int startTime() throws NumberFormatException:
{
    Token t;
    int startTime = 0;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 23) })
        t = < NUMBER >
        {
            int hour = Integer.parseInt(t.image);
            startTime = hour * 60;
        }
    )
    < COLON >
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 59) && (getToken(1).image.length() >= 2 || "0".equals(getToken(1).image))})
        t = < NUMBER >
        {
            int minute = Integer.parseInt(t.image);
            startTime += minute;
        }
    )
    {
        return startTime;
    }
}

void differentRange() throws NumberFormatException:
{
    Token t;
    int day = 0;
    int hour = 0;
    int minute = 0;
    int range = 0;
}
{
    < ISO_PERIOD >
    (
        // TODO: Fix this DAYS_PH and ISO_DAYS ordeal here
        LOOKAHEAD( { getToken(2).kind == DAYS_PH })
        t = < NUMBER >
        {
            day = Integer.parseInt(t.image);
        }
        <DAYS_PH>
    )?
    (
        LOOKAHEAD( { getToken(1).kind == ISO_TIME } )
        < ISO_TIME >
        (
            LOOKAHEAD({ getToken(2).kind == ISO_HOUR })
            t = < NUMBER >
            {
                hour = Integer.parseInt(t.image);
            }
            < ISO_HOUR >
        )?
        (
            LOOKAHEAD({ getToken(2).kind == ISO_MINUTE })
            t = < NUMBER >
            {
                minute = Integer.parseInt(t.image);
            }
            < ISO_MINUTE >
        )?
    )?
    {
        range = day * 24 * 60 + hour * 60 + minute;
        rule.setRange(range);
    }
}

void ifRule() throws NumberFormatException:
{
    Token t;
    List< List < Integer > > ifWeekdays = new ArrayList< List < Integer > >();
    List< Integer > altTime = new ArrayList< Integer >();
    List< List < Integer > > altWeekdays = new ArrayList< List < Integer > >();
    rule.setIfWeekdays(ifWeekdays);
    rule.setAlternateTime(altTime);
    rule.setAlternateWeekdays(altWeekdays);

    List< List < Integer > > ifWeekdaysExtra = new ArrayList< List < Integer > >();
    List< List < Integer > > extraWeekdays = new ArrayList< List < Integer > >();
    rule.setIfWeekdaysExtra(ifWeekdaysExtra);
    rule.setExtraWeekdays(extraWeekdays);

    int time = 0;
}
{
    ifWeekday()
    ( ifWeekday() )*
}

void ifWeekday() throws NumberFormatException:
{
    Token and = null;
    int weekday = 0;
}
{
    LOOKAHEAD( < AND > )
    extraWeekday()
    |
    ifWeekdayThenTime()
}

void extraWeekday() throws NumberFormatException:
{
    Token t;
    List< List < Integer > > ifWeekdaysExtra = rule.getIfWeekdaysExtra();
    List< List < Integer > > extraWeekdays = rule.getExtraWeekdays();

    int weekday = 0;
    int previousOrNext = 1; // 0 = previous, 1 = next
}
{
    (
        < AND >
        < IF >
        (
            {
                List < Integer > ifWeekday = new ArrayList< Integer >();
            }
            t = < WEEKDAY >
            {
                ifWeekday.add(Date.weekdayToValue(t.image));
            }
            (
                < COMMA >
                t = < WEEKDAY >
                {
                    ifWeekday.add(Date.weekdayToValue(t.image));
                }
            )*
        )
        < THEN >
        (
            (
                (
                    < NEXT >
                    {
                        previousOrNext = 1;
                    }
                    |
                    < PREVIOUS >
                    {
                        previousOrNext = 0;
                    }
                )
                t = < WEEKDAY >
                {
                    weekday = Date.weekdayToValue(t.image);
                }
            )
            {
                List < Integer > extraWeekday = new ArrayList < Integer >();
                extraWeekday.add(weekday);
                extraWeekday.add(previousOrNext);
                extraWeekdays.add(extraWeekday);
            }
        )
        {
            ifWeekdaysExtra.add(ifWeekday);
        }
    )
}
    

void ifWeekdayThenTime() throws NumberFormatException:
{
    Token t;
    List< List < Integer > > ifWeekdays = rule.getIfWeekdays();
    List< Integer > altTime = rule.getAlternateTime();
    List< List < Integer > > altWeekdays = rule.getAlternateWeekdays();
    int time = 0;

    int weekday = 0;
    int previousOrNext = 1; // 0 = previous, 1 = next
}
{
    (
        < IF >
        (
            {
                List < Integer > ifWeekday = new ArrayList< Integer >();
            }
            t = < WEEKDAY >
            {
                ifWeekday.add(Date.weekdayToValue(t.image));
            }
            (
                < COMMA >
                t = < WEEKDAY >
                {
                    ifWeekday.add(Date.weekdayToValue(t.image));
                }
            )*
            {
                ifWeekdays.add(ifWeekday);
            }
        )
        < THEN >
        (
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 23) && (getToken(1).image.length() >= 2 || "0".equals(getToken(1).image))})
                t = < NUMBER >
                {
                    time = 0;
                    time = Integer.parseInt(t.image) * 60; // hour
                }
            )
            < COLON >
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 59) && (getToken(1).image.length() >= 2 || "0".equals(getToken(1).image))})
                t = < NUMBER >
                {
                    time += Integer.parseInt(t.image); // minute
                }
            )
            {
                altTime.add(time);
                altWeekdays.add(null);
            }
        |
            (
                (
                    < NEXT >
                    {
                        previousOrNext = 1;
                    }
                    |
                    < PREVIOUS >
                    {
                        previousOrNext = 0;
                    }
                )
                t = < WEEKDAY >
                {
                    weekday = Date.weekdayToValue(t.image);
                }
            )
            {
                List < Integer > altWeekday = new ArrayList < Integer >();
                altWeekday.add(weekday);
                altWeekday.add(previousOrNext);
                altWeekdays.add(altWeekday);
                altTime.add(null);
            }
        )
    )
}

void specialYear() :
{
    Token t;
}
{
    < IN >
    (
        (
            < EVEN >
            {
                rule.setInEvenYearOnly(true);
            }
        )
        |
        (
            < ODD >
            {
                rule.setInOddYearOnly(true);
            }
        )
        |
        (
            < LEAP >
            {
                rule.setInLeapYearOnly(true);
            }
        )
        |
        (
            < NON_LEAP >
            {
                rule.setInNonLeapYearOnly(true);
            }
        )
    )
}

Date gregorianDate() throws NumberFormatException:
{
    Token t;
    int year = DEFAULT_YEAR;
    int month;
    int dayOfMonth;
}
{
    (
        t = < YEAR >
        {
            year = Integer.parseInt(t.image);
        }
        < DASH >
    )?
    (
        t = < NUMBER >
        {
            if (t.image.length() != 2 ) {
                throw new ParseException("Month must be defined as MM");
            }
            month = Integer.parseInt(t.image);
            if (month > 12 || month < 1) {
                throw new ParseException("Month must be between 1-12, not " + month);
            }
        }
    )
    < DASH >
    (
        t = < NUMBER >
        {
            if (t.image.length() != 2) {
                throw new ParseException("Day must be defined as DD");
            }
            dayOfMonth = Integer.parseInt(t.image);
            if (dayOfMonth > 31 || month < 1) {
                throw new ParseException("Day must be between 1-31, not " + dayOfMonth);
            }
        }
    )
    {
        GregorianDate d = new GregorianDate(year, month, dayOfMonth);
        return d;
    }
}

Date startOfMonth():
{
    Token t;
    String m;    
    int month;
    Date d;
}
{
    (
        m = month()
        {
            month = GregorianMonth.fromName(m).getValue();
        }
        (
            LOOKAHEAD ({ getToken(1).kind == SOLSTICE || getToken(1).kind == EQUINOX })
            d = equinoxSolstice()
        |
            {
                d = new GregorianDate(DEFAULT_YEAR, month, 1);
            }
        )
    )
    {
        try {
            d.setMonth(month);
        } catch (IllegalArgumentException e) {
            throw new ParseException("Problem in setting month for equinox/solstice");
        }
        return d;   
    }
}

String month() :
{
  Token m = null;
}
{
  m = < GREGORIAN_MONTH >
  {
    return m.image;
  }
}

Date equinoxSolstice():
{
    Token t;
    Date d;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == EQUINOX })
        < EQUINOX >
        {
            d = new EquinoxDate();
        }
    |
        LOOKAHEAD({ getToken(1).kind == SOLSTICE })
        < SOLSTICE >
        {
            d = new SolsticeDate();
        }
    |
        {
            throw new ParseException("Expected equinox or solstice");
        }
    )
    (
        < IN >
        t = < TIMEZONE >
        {
            d.setTimezone(t.image);
        }
    )?
    {
        return d;
    }
}

Date easterOrthodox() throws NumberFormatException:
{
    Token t;
    boolean isPlus = true;
    boolean isOrthodox = false;
    Token sign;
    int offset = 0;
}
{
    t = < EASTER >
    {
        if (t.image.equals("Orthodox")) {
            isOrthodox = true;
        }
    }
    (
        sign = < PLUS >
    |
        sign = < DASH >
        {
            isPlus = false;
        }
    )?
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && getToken(2).kind != COLON })
        (
            t = < NUMBER >
            {
                offset = (isPlus) ? Integer.parseInt(t.image) : Integer.parseInt(t.image) * -1;
            }
        )
    )?
    {
        EasterDate d = new EasterDate(DEFAULT_YEAR, isOrthodox, offset);
        return d;
    }
}

Date hijra() throws NumberFormatException:
{
    Token t;
    int dayOfMonth;
    int month;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 30) })
        t = < NUMBER >
        {
            dayOfMonth = Integer.parseInt(t.image);
        }
        t = < HIJRA_MONTH >
        {
            month = HijraMonth.fromName(t.image).getValue();
        }
    )
    {
        HijraDate d = new HijraDate(month, dayOfMonth);
        return d;
    }
}

Date hebrew() throws NumberFormatException:
{
    Token t;
    int dayOfMonth;
    int month;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 28) })
        t = < NUMBER >
        {
            dayOfMonth = Integer.parseInt(t.image);
        }
        t = < HEBREW_MONTH >
        {
            month = HebrewMonth.fromName(t.image).getValue();
        }
    )
    {
        HebrewDate hebrewDate = new HebrewDate(month, dayOfMonth);
        return hebrewDate;
    }
}

// TODO: Refactor this to be more readable
Date eastAsian() throws NumberFormatException:
{
    Token t;
    CalendarType calType;
    int cycle = EastAsianDate.DEFAULT_EAST_ASIAN_CYCLE;
    int yearOfCycle = EastAsianDate.DEFAULT_EAST_ASIAN_YEAR_OF_CYCLE;
    int month;
    boolean isLeapMonth;
    int dayOfMonth;

    int solarTermTh;
    int solarTermDay;

    EastAsianDate d = new EastAsianDate();
}
{
    (
        t = < EASTASIAN_CALENDER >
        {
            calType = CalendarType.fromName(t.image);
            d.setCalendarType(calType);
        }
    )
    (
        // look for cycle
        LOOKAHEAD({ getToken(6).kind == DASH })
        (
            t = < NUMBER >
            {
                cycle = Integer.parseInt(t.image);
                d.setCycle(cycle);
            }
            < DASH >
        )
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 60) })
            t = < NUMBER >
            {
                yearOfCycle = Integer.parseInt(t.image);
                d.setYearOfCycle(yearOfCycle);
            }
            < DASH >
        )
    )?
    (
        LOOKAHEAD({ getToken(4).kind == SOLARTERM })
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 24) })
            (
                t = < NUMBER >
                {
                    solarTermTh = Integer.parseInt(t.image);
                    d.setSolarTermTh(solarTermTh);
                }
            )
            <DASH>
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 15) })
            (
                t = < NUMBER >
                {
                    solarTermDay = Integer.parseInt(t.image);
                    d.setSolarTermDay(solarTermDay);
                }
            )
            < SOLARTERM >
        )?
    |
        (
            (
                t = < NUMBER >
                {
                    month = Integer.parseInt(t.image);
                    d.setMonth(month);
                }
                < DASH >
            )
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 1) })
                (
                    t = < NUMBER >
                    {
                        isLeapMonth = (Integer.parseInt(t.image) == 1);
                        d.setLeapMonth(isLeapMonth);
                    }
                    < DASH>
                )
            )
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 30) })
                (
                    t = < NUMBER >
                    {
                        dayOfMonth = Integer.parseInt(t.image);
                        d.setDayOfMonth(dayOfMonth);
                    }
                )
            )
        )?
    )
    {
        return d;
    }
}

Date bengaliRevised() throws NumberFormatException:
{
    Token t;
    BengaliDate d = new BengaliDate();
}
{
    < BENGALI_REVISED>
    (
        t = < YEAR >
        {
            d.setYear(Integer.parseInt(t.image));
        }
        < DASH >
    )?
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 12) })
        (
            t = < NUMBER >
            {
                d.setMonth(Integer.parseInt(t.image));
            }
        )
    )
    < DASH >
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 31) })
        (
            t = < NUMBER >
            {
                d.setDayOfMonth(Integer.parseInt(t.image));
            }
        )
  
    )
    {
        return d;
    }
}

Date nthWeekday() throws NumberFormatException:
{
    Token t;
    int nth;
    int weekday;
    int month;
    boolean isInMonth;
    NthDate nthDate = new NthDate();
}
{
    (
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 100) })
            t = < NUMBER >
            {
                nth = Integer.parseInt(t.image);
            }
            < COUNT_SUFFIX >
        )
        (
            t = < WEEKDAY >
            {
                weekday = Date.weekdayToValue(t.image);
            }
        )
        (
            < IN >
            {
                isInMonth = true;
            }
            |
            < BEFORE >
            {
                isInMonth = false;
            }
        )
        (
            t = < GREGORIAN_MONTH >
            {
                month = GregorianMonth.fromName(t.image).getValue();
            }
        )
    )
    {
        nthDate.setYear(2021);
        nthDate.setNth(nth);
        nthDate.setWeekday(weekday);
        nthDate.setInMonth(isInMonth);
        nthDate.setMonth(month);
        return nthDate;
    }
}
