options
{
  JDK_VERSION = "1.8";

  static = false;

  LOOKAHEAD= 6;
  IGNORE_CASE = true;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 2;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(HolidayParser)

package worldholidaydates.holidayparser;

import java.util.ArrayList;
import java.util.Locale;
import java.util.List;

import worldholidaydates.Utils;
import worldholidaydates.holidayparser.EastAsianDate.CalendarType;
import worldholidaydates.holidayparser.HijraDate.HijraMonth;
import worldholidaydates.holidayparser.HebrewDate.HebrewMonth;
import worldholidaydates.holidayparser.GregorianDate.GregorianMonth;

public class HolidayParser {
    static int DEFAULT_YEAR = 2021;
    Rule rule;

    public static void main (String[] args) throws ParseException, TokenMgrError {
        // nothing here
    }

    public Rule parse() throws ParseException {
        rule = new Rule();
        return start();
    }

}

PARSER_END(HolidayParser)

SKIP : { " " }
TOKEN :
{
    < DASH : "-" >
|   < PLUS : "+" >
|   < COLON : ":" >
|   < COMMA : "," >
}

TOKEN : { < YEAR :  (< DIGIT >){4} > }

TOKEN :
{
    < GREGORIAN_MONTH :
      "January"
    | "Febuary"
    | "March"
    | "April"
    | "May"
    | "June"
    | "July"
    | "August"
    | "September"
    | "October"
    | "November"
    | "December" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < HIJRA_MONTH:
        "Muharram"
    |   "Safar"
    |   "Rabi al-awwal"
    |   "Rabi al-thani"
    |   "Jumada al-awwal"
    |   "Jumada al-thani"
    |   "Rajab"
    |   "Shaban"
    |   "Ramadan"
    |   "Shawwal"
    |   "Dhu al-Qidah"
    |   "Dhu al-Hijjah" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < HEBREW_MONTH:
        "Nisan"
    |   "Iyyar"
    |   "Sivan"
    |   "Tamuz"
    |   "Av"
    |   "Elul"
    |   "Tishrei"
    |   "Cheshvan"
    |   "Kislev"
    |   "Tevet"
    |   "Shvat"
    |   "Adar">
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
}

TOKEN :
{
    < WEEKDAY : 
        "Monday"
    |   "Tuesday"
    |   "Wednesday"
    |   "Thursday"
    |   "Friday"
    |   "Saturday"
    |   "Sunday" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < AFTER_BEFORE :
        "after"
    |   "before" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < DAYS_PH :
        "days"
    |   "d" >
}

TOKEN :
{
    < ISO_PERIOD : "P" >
|   < ISO_DAY : "D" >
|   < ISO_TIME : "T" >
|   < ISO_HOUR : "H" >
|   < ISO_MINUTE : "M" >
    {
        matchedToken.image = image.toString().toUpperCase(Locale.US);
    }
}

TOKEN :
{
    < EASTER :
        "Easter"
    |   "Orthodox" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
}

TOKEN : 
{
    < EASTASIAN_CALENDER :
        "Chinese"
    |   "Korean"
    |   "Vietnamese" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < SOLARTERM : "solarterm" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < BENGALI_REVISED :
        "bengali-revised" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN:
{
    < SOLSTICE :
        "solstice" >
|
    < EQUINOX:
        "equinox" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < NUMBER : (< DIGIT >)+ >
|   < DIGIT : [ "0"-"9" ] >
}

TOKEN :
{
    < COUNT_SUFFIX:
        "st"
    |   "nd"
    |   "rd"
    |   "th" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
|
    < IN : "in" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN :
{
    < TIMEZONE :
        (["A"-"Z"]){3}
    |   (< PLUS > | < DASH >) <NUMBER> ":" <NUMBER>
    |    (["a"-"z","A"-"Z"])+ "/" (["a"-"z","A"-"Z"])+ >
}

TOKEN :
{
    < IF : "if" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
|   < THEN : "then" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

Rule start():
{
    Date d = null;
    int startTime = 0;
    int range = 0;
    List < List < Integer > > ifWeekdays = new ArrayList < List < Integer > > ();
    List < Integer > altTime = new ArrayList < Integer > ();
}
{
    (
        LOOKAHEAD( offset() )
        offset()
    )?
    (
        (
            LOOKAHEAD( gregorianDate() )
            (
                d = gregorianDate()
            )?
        |
            LOOKAHEAD( startOfMonth() )
            (
                d = startOfMonth()
            )?
        |
            LOOKAHEAD( easterOrthodox() )
            (
                d = easterOrthodox()
            )?
        |
            LOOKAHEAD( hijra() )
            (
                d = hijra()
            )?
        |
            LOOKAHEAD( hebrew() )
            (
                d = hebrew()
            )?
        |
            LOOKAHEAD( eastAsian() )
            (
                d = eastAsian()
            )?
        |
            LOOKAHEAD( bengaliRevised() )
            (
                d = bengaliRevised()
            )?
        )
    )
    (
        LOOKAHEAD( < NUMBER > < COLON > < NUMBER > )
        (
            startTime = startTime()
            {
                d.setStartTime(startTime);
            }
        )
    )?
    (
        LOOKAHEAD( < ISO_PERIOD > )
        (
            differentRange()
        )
    )?
    (
        LOOKAHEAD( ifRule() )
        (
            ifRule()
        )
    )?
    < EOF >
    {
        if (d != null) {
            rule.setRawDate(d);
        }
        // TODO: refactor this
        if (rule.getIfWeekdays() == null) {
            rule.setIfWeekdays(ifWeekdays);
        }
        if (rule.getAlternateTime() == null) {
            rule.setAlternateTime(altTime);
        }
        return rule;
    }
}

void offset() throws NumberFormatException:
{
    Token t;
    boolean isAfter;
    int offset = 0;
}
{
    (
        (
            LOOKAHEAD( weekdayOffset() )
                weekdayOffset()
            |
            LOOKAHEAD( dayOffset() )
                dayOffset()
        )
        t = < AFTER_BEFORE >
        {
            isAfter = t.image.equals("after");
            rule.setOffsetDirection(isAfter);
        }
    )
}

void dayOffset() throws NumberFormatException:
{
    Token t;
    int offset = 0;
}
{
    (
        t = < NUMBER >
        {
            offset = Integer.parseInt(t.image);
            rule.setOffset(offset);
        }
        (< DAYS_PH >)?
    )
}

void weekdayOffset() throws NumberFormatException:
{
    Token t;
    int offsetWeekDayNth = 1;
    int offsetWeekDay = 0;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER })
        t = < NUMBER >
        {
            offsetWeekDayNth = Integer.parseInt(t.image);
            rule.setOffsetWeekDayNth(offsetWeekDayNth);
        }
        < COUNT_SUFFIX >
        t = < WEEKDAY >
        {
            offsetWeekDay = Date.weekdayToValue(t.image);
            rule.setOffsetWeekDay(offsetWeekDay);
        }
    )
}

int startTime() throws NumberFormatException:
{
    Token t;
    int startTime = 0;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 23) })
        t = < NUMBER >
        {
            int hour = Integer.parseInt(t.image);
            startTime = hour * 60;
        }
    )
    < COLON >
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 59) && (getToken(1).image.length() >= 2 || "0".equals(getToken(1).image))})
        t = < NUMBER >
        {
            int minute = Integer.parseInt(t.image);
            startTime += minute;
        }
    )
    {
        return startTime;
    }
}

void differentRange() throws NumberFormatException:
{
    Token t;
    int day = 0;
    int hour = 0;
    int minute = 0;
    int range = 0;
}
{
    < ISO_PERIOD >
    (
        // TODO: Fix this DAYS_PH and ISO_DAYS ordeal here
        LOOKAHEAD( { getToken(2).kind == DAYS_PH })
        t = < NUMBER >
        {
            day = Integer.parseInt(t.image);
        }
        <DAYS_PH>
    )?
    < ISO_TIME >
    (
        LOOKAHEAD({ getToken(2).kind == ISO_HOUR })
        t = < NUMBER >
        {
            hour = Integer.parseInt(t.image);
        }
        < ISO_HOUR >
    )?
    (
        LOOKAHEAD({ getToken(2).kind == ISO_MINUTE })
        t = < NUMBER >
        {
            minute = Integer.parseInt(t.image);
        }
        < ISO_MINUTE >
    )?
    {
        range = day * 24 * 60 + hour * 60 + minute;
        rule.setRange(range);
    }
}

void ifRule() throws NumberFormatException:
{
    Token t;
    List< List < Integer > > ifWeekdays = new ArrayList< List < Integer > >();
    List< Integer > altTime = new ArrayList< Integer >();
    rule.setIfWeekdays(ifWeekdays);
    rule.setAlternateTime(altTime);
    int time = 0;
}
{
    ifWeekdayThenTime()
    ( ifWeekdayThenTime() )*
}

void ifWeekdayThenTime() throws NumberFormatException:
{
    Token t;
    List< List < Integer > > ifWeekdays = rule.getIfWeekdays();
    List< Integer > altTime = rule.getAlternateTime();
    int time = 0;
}
{
    (
        < IF >
        {
            List < Integer > ifWeekday = new ArrayList< Integer >();
        }
        t = < WEEKDAY >
        {
            ifWeekday.add(Date.weekdayToValue(t.image));
        }
        (
            < COMMA >
            t = < WEEKDAY >
            {
                ifWeekday.add(Date.weekdayToValue(t.image));
            }
        )*
        < THEN >
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 23) && (getToken(1).image.length() >= 2 || "0".equals(getToken(1).image))})
            t = < NUMBER >
            {
                time = 0;
                time = Integer.parseInt(t.image) * 60; // hour
            }
        )
        < COLON >
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 59) && (getToken(1).image.length() >= 2 || "0".equals(getToken(1).image))})
            t = < NUMBER >
            {
                time += Integer.parseInt(t.image); // minute
            }
        )
        {
            altTime.add(time);
            ifWeekdays.add(ifWeekday);
        }
    )
}

Date gregorianDate() throws NumberFormatException:
{
    Token t;
    int year = DEFAULT_YEAR;
    int month;
    int dayOfMonth;
}
{
    (
        t = < YEAR >
        {
            year = Integer.parseInt(t.image);
        }
        < DASH >
    )?
    (
        t = < NUMBER >
        {
            if (t.image.length() != 2 ) {
                throw new ParseException("Month must be defined as MM");
            }
            month = Integer.parseInt(t.image);
            if (month > 12 || month < 1) {
                throw new ParseException("Month must be between 1-12, not " + month);
            }
        }
    )
    < DASH >
    (
        t = < NUMBER >
        {
            if (t.image.length() != 2) {
                throw new ParseException("Day must be defined as DD");
            }
            dayOfMonth = Integer.parseInt(t.image);
            if (dayOfMonth > 31 || month < 1) {
                throw new ParseException("Day must be between 1-31, not " + dayOfMonth);
            }
        }
    )
    {
        GregorianDate d = new GregorianDate(year, month, dayOfMonth);
        return d;
    }
}

Date startOfMonth():
{
    Token t;
    String m;    
    int month;
    Date d;
}
{
    (
        m = month()
        {
            month = GregorianMonth.fromName(m).getValue();
        }
        (
            LOOKAHEAD ({ getToken(1).kind == SOLSTICE || getToken(1).kind == EQUINOX })
            d = equinoxSolstice()
        |
            {
                d = new GregorianDate(DEFAULT_YEAR, month, 1);
            }
        )
    )
    {
        try {
            d.setMonth(month);
        } catch (IllegalArgumentException e) {
            throw new ParseException("Problem in setting month for equinox/solstice");
        }
        return d;   
    }
}

String month() :
{
  Token m = null;
}
{
  m = < GREGORIAN_MONTH >
  {
    return m.image;
  }
}

Date equinoxSolstice():
{
    Token t;
    Date d;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == EQUINOX })
        < EQUINOX >
        {
            d = new EquinoxDate();
        }
    |
        LOOKAHEAD({ getToken(1).kind == SOLSTICE })
        < SOLSTICE >
        {
            d = new SolsticeDate();
        }
    |
        {
            throw new ParseException("Expected equinox or solstice");
        }
    )
    (
        < IN >
        t = < TIMEZONE >
        {
            d.setTimezone(t.image);
        }
    )?
    {
        return d;
    }
}

Date easterOrthodox() throws NumberFormatException:
{
    Token t;
    boolean isPlus = true;
    boolean isOrthodox = false;
    Token sign;
    int offset = 0;
}
{
    t = < EASTER >
    {
        if (t.image.equals("Orthodox")) {
            isOrthodox = true;
        }
    }
    (
        sign = < PLUS >
    |
        sign = < DASH >
        {
            isPlus = false;
        }
    )?
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && getToken(2).kind != COLON })
        (
            t = < NUMBER >
            {
                offset = (isPlus) ? Integer.parseInt(t.image) : Integer.parseInt(t.image) * -1;
            }
        )
    )?
    {
        EasterDate d = new EasterDate(DEFAULT_YEAR, isOrthodox, offset);
        return d;
    }
}

Date hijra() throws NumberFormatException:
{
    Token t;
    int dayOfMonth;
    int month;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 30) })
        t = < NUMBER >
        {
            dayOfMonth = Integer.parseInt(t.image);
        }
        t = < HIJRA_MONTH >
        {
            month = HijraMonth.fromName(t.image).getValue();
        }
    )
    {
        HijraDate d = new HijraDate(month, dayOfMonth);
        return d;
    }
}

Date hebrew() throws NumberFormatException:
{
    Token t;
    int dayOfMonth;
    int month;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 28) })
        t = < NUMBER >
        {
            dayOfMonth = Integer.parseInt(t.image);
        }
        t = < HEBREW_MONTH >
        {
            month = HebrewMonth.fromName(t.image).getValue();
        }
    )
    {
        HebrewDate hebrewDate = new HebrewDate(month, dayOfMonth);
        return hebrewDate;
    }
}

// TODO: Refactor this to be more readable
Date eastAsian() throws NumberFormatException:
{
    Token t;
    CalendarType calType;
    int cycle = EastAsianDate.DEFAULT_EAST_ASIAN_CYCLE;
    int yearOfCycle = EastAsianDate.DEFAULT_EAST_ASIAN_YEAR_OF_CYCLE;
    int month;
    boolean isLeapMonth;
    int dayOfMonth;

    int solarTermTh;
    int solarTermDay;

    EastAsianDate d = new EastAsianDate();
}
{
    (
        t = < EASTASIAN_CALENDER >
        {
            calType = CalendarType.fromName(t.image);
            d.setCalendarType(calType);
        }
    )
    (
        // look for cycle
        LOOKAHEAD({ getToken(6).kind == DASH })
        (
            t = < NUMBER >
            {
                cycle = Integer.parseInt(t.image);
                d.setCycle(cycle);
            }
            < DASH >
        )
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 60) })
            t = < NUMBER >
            {
                yearOfCycle = Integer.parseInt(t.image);
                d.setYearOfCycle(yearOfCycle);
            }
            < DASH >
        )
    )?
    (
        LOOKAHEAD({ getToken(4).kind == SOLARTERM })
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 24) })
            (
                t = < NUMBER >
                {
                    solarTermTh = Integer.parseInt(t.image);
                    d.setSolarTermTh(solarTermTh);
                }
            )
            <DASH>
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 15) })
            (
                t = < NUMBER >
                {
                    solarTermDay = Integer.parseInt(t.image);
                    d.setSolarTermDay(solarTermDay);
                }
            )
            < SOLARTERM >
        )?
    |
        (
            (
                t = < NUMBER >
                {
                    month = Integer.parseInt(t.image);
                    d.setMonth(month);
                }
                < DASH >
            )
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 1) })
                (
                    t = < NUMBER >
                    {
                        isLeapMonth = (Integer.parseInt(t.image) == 1);
                        d.setLeapMonth(isLeapMonth);
                    }
                    < DASH>
                )
            )
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 30) })
                (
                    t = < NUMBER >
                    {
                        dayOfMonth = Integer.parseInt(t.image);
                        d.setDayOfMonth(dayOfMonth);
                    }
                )
            )
        )?
    )
    {
        return d;
    }
}

Date bengaliRevised() throws NumberFormatException:
{
    Token t;
    BengaliDate d = new BengaliDate();
}
{
    < BENGALI_REVISED>
    (
        t = < YEAR >
        {
            d.setYear(Integer.parseInt(t.image));
        }
        < DASH >
    )?
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 12) })
        (
            t = < NUMBER >
            {
                d.setMonth(Integer.parseInt(t.image));
            }
        )
    )
    < DASH >
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 31) })
        (
            t = < NUMBER >
            {
                d.setDayOfMonth(Integer.parseInt(t.image));
            }
        )
  
    )
    {
        return d;
    }
}
