options
{
  JDK_VERSION = "1.8";

  static = false;

  LOOKAHEAD= 6;
  IGNORE_CASE = true;
  FORCE_LA_CHECK = true;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 2;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(HolidayParser)

package worldholidaydates.holidayparser;

import java.util.Locale;

import worldholidaydates.Utils;
import worldholidaydates.holidayparser.EastAsianDate.CalendarType;
import worldholidaydates.holidayparser.HijraDate.HijraMonth;
import worldholidaydates.holidayparser.HebrewDate.HebrewMonth;
import worldholidaydates.holidayparser.GregorianDate.GregorianMonth;

public class HolidayParser {
    static int DEFAULT_YEAR = 2021;

    public static void main (String[] args) throws ParseException, TokenMgrError {
        // nothing here
    }

    public Rule parse() throws ParseException {
        return start();
    }

}

PARSER_END(HolidayParser)

SKIP : { " " }
TOKEN : { < DASH : "-" > }

TOKEN : { < YEAR :  (< DIGIT >){4} > }

TOKEN :
{
    < GREGORIAN_MONTH :
      "January"
    | "Febuary"
    | "March"
    | "April"
    | "May"
    | "June"
    | "July"
    | "August"
    | "September"
    | "October"
    | "November"
    | "December" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < HIJRA_MONTH:
        "Muharram"
    |   "Safar"
    |   "Rabi al-awwal"
    |   "Rabi al-thani"
    |   "Jumada al-awwal"
    |   "Jumada al-thani"
    |   "Rajab"
    |   "Shaban"
    |   "Ramadan"
    |   "Shawwal"
    |   "Dhu al-Qidah"
    |   "Dhu al-Hijjah" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < HEBREW_MONTH:
        "Nisan"
    |   "Iyyar"
    |   "Sivan"
    |   "Tamuz"
    |   "Av"
    |   "Elul"
    |   "Tishrei"
    |   "Cheshvan"
    |   "Kislev"
    |   "Tevet"
    |   "Shvat"
    |   "Adar">
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
}

TOKEN :
{
    < EASTER :
        "Easter"
    |   "Orthodox" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
}

TOKEN : 
{
    < EASTASIAN_CALENDER:
        "Chinese"
    |   "Korean"
    |   "Vietnamese" >
    {
        matchedToken.image = Utils.capitalize(image.toString());
    }
|
    < SOLARTERM : "solarterm" >
    {
        matchedToken.image = image.toString().toLowerCase(Locale.US);
    }
}

TOKEN:
{
    < PLUS : "+" >
}

TOKEN :
{
  < NUMBER : (< DIGIT >)+ >
}

TOKEN :
{
  < DIGIT : [ "0"-"9" ] >
}

TOKEN :
{
    < TEST: "T" >
}

Rule start():
{
    Rule r = new Rule();
    Date d = null;
}
{
    (
        (
            LOOKAHEAD( gregorianDate() )
            (
                d = gregorianDate()
            )?
        |
            LOOKAHEAD( startOfMonth() )
            (
                d = startOfMonth()
            )?
        |
            LOOKAHEAD( easterOrthodox() )
            (
                d = easterOrthodox()
            )?
        |
            LOOKAHEAD( hijra() )
            (
                d = hijra()
            )?
        |
            LOOKAHEAD( hebrew() )
            (
                d = hebrew()
            )?
        |
            LOOKAHEAD( eastAsian() )
            (
                d = eastAsian()
            )?
        )
        < EOF >
    )
    {
        if (d != null) {
            r.setMainDate(d);
        }
        return r;
    }
}

Date gregorianDate() throws NumberFormatException:
{
    Token t;
    int year = DEFAULT_YEAR;
    int month;
    int day;
}
{
    (
        t = < YEAR >
        {
            year = Integer.parseInt(t.image);
        }
        < DASH >
    )?
    (
        t = < NUMBER >
        {
            if (t.image.length() != 2 ) {
                throw new ParseException("Month must be defined as MM");
            }
            month = Integer.parseInt(t.image);
            if (month > 12 || month < 1) {
                throw new ParseException("Month must be between 1-12, not " + month);
            }
        }
    )
    < DASH >
    (
        t = < NUMBER >
        {
            if (t.image.length() != 2) {
                throw new ParseException("Day must be defined as DD");
            }
            day = Integer.parseInt(t.image);
            if (day > 31 || month < 1) {
                throw new ParseException("Day must be between 1-31, not " + day);
            }
        }
    )
    {
        GregorianDate d = new GregorianDate(year, month, day);
        return d;
    }
}

Date startOfMonth():
{
    String m;    
    int month;
}
{
    (
        m = month()
        {
            month = GregorianMonth.toMonth(m);
        }
    )
    {
        GregorianDate d = new GregorianDate(DEFAULT_YEAR, month, 1);
        return d;        
    }
}

String month() :
{
  Token m = null;
}
{
  m = < GREGORIAN_MONTH >
  {
    return m.image;
  }
}

Date easterOrthodox() throws NumberFormatException:
{
    Token t;
    boolean isPlus = true;
    boolean isOrthodox = false;
    Token sign;
    int offset = 0;
}
{
    t = < EASTER >
    {
        if (t.image.equals("Orthodox")) {
            isOrthodox = true;
        }
    }
    (
        sign = < PLUS >
    |
        sign = < DASH >
        {
            isPlus = false;
        }
    )?
    (
        t = < NUMBER >
        {
            offset = (isPlus) ? Integer.parseInt(t.image) : Integer.parseInt(t.image) * -1;
        }
    )?
    {
        EasterDate easterDate = new EasterDate(DEFAULT_YEAR, isOrthodox, offset);
        return easterDate;
    }
}

Date hijra() throws NumberFormatException:
{
    Token t;
    int dayOfMonth;
    HijraMonth month;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 30) })
        t = < NUMBER >
        {
            dayOfMonth = Integer.parseInt(t.image);
        }
        t = < HIJRA_MONTH >
        {
            month = HijraMonth.fromName(t.image);
        }
    )
    {
        HijraDate hijraDate = new HijraDate(month, dayOfMonth);
        return hijraDate;
    }
}

Date hebrew() throws NumberFormatException:
{
    Token t;
    int dayOfMonth;
    HebrewMonth month;
}
{
    (
        LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 28) })
        t = < NUMBER >
        {
            dayOfMonth = Integer.parseInt(t.image);
        }
        t = < HEBREW_MONTH >
        {
            month = HebrewMonth.fromName(t.image);
        }
    )
    {
        HebrewDate hebrewDate = new HebrewDate(month, dayOfMonth);
        return hebrewDate;
    }
}

// TODO: Refactor this to be more readable
Date eastAsian() throws NumberFormatException:
{
    Token t;
    CalendarType calType;
    int cycle = EastAsianDate.DEFAULT_EAST_ASIAN_CYCLE;
    int yearOfCycle = EastAsianDate.DEFAULT_EAST_ASIAN_YEAR_OF_CYCLE;
    int month;
    boolean isLeapMonth;
    int dayOfMonth;

    int solarTermTh;
    int solarTermDay;

    EastAsianDate eastAsianDate = new EastAsianDate();
}
{
    (
        t = < EASTASIAN_CALENDER >
        {
            calType = CalendarType.fromName(t.image);
            eastAsianDate.setCalendarType(calType);
        }
    )
    (
        // look for cycle
        LOOKAHEAD({ getToken(6).kind == DASH })
        (
            t = < NUMBER >
            {
                cycle = Integer.parseInt(t.image);
                eastAsianDate.setCycle(cycle);
            }
            < DASH >
        )
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 60) })
            t = < NUMBER >
            {
                yearOfCycle = Integer.parseInt(t.image);
                eastAsianDate.setYearOfCycle(yearOfCycle);
            }
            < DASH >
        )
    )?
    (
        LOOKAHEAD({ getToken(4).kind == DASH })
        (
            (
                t = < NUMBER >
                {
                    month = Integer.parseInt(t.image);
                    eastAsianDate.setMonth(month);
                }
                < DASH >
            )
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 0, 1) })
                (
                    t = < NUMBER >
                    {
                        isLeapMonth = (Integer.parseInt(t.image) == 1);
                        eastAsianDate.setLeapMonth(isLeapMonth);
                    }
                    < DASH>
                )
            )
            (
                LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 30) })
                (
                    t = < NUMBER >
                    {
                        dayOfMonth = Integer.parseInt(t.image);
                        eastAsianDate.setDay(dayOfMonth);
                    }
                )
            )
        )?
    |
        (
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 24) })
            (
                t = < NUMBER >
                {
                    solarTermTh = Integer.parseInt(t.image);
                    eastAsianDate.setSolarTermTh(solarTermTh);
                }
            )
            <DASH>
            LOOKAHEAD({ getToken(1).kind == NUMBER && Utils.between(getToken(1).image, 1, 15) })
            (
                t = < NUMBER >
                {
                    solarTermDay = Integer.parseInt(t.image);
                    eastAsianDate.setSolarTermDay(solarTermDay);
                }
            )
        )?
    )
    {
        return eastAsianDate;
    }
}
